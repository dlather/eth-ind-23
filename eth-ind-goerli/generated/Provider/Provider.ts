// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class DataAsserted extends ethereum.Event {
  get params(): DataAsserted__Params {
    return new DataAsserted__Params(this);
  }
}

export class DataAsserted__Params {
  _event: DataAsserted;

  constructor(event: DataAsserted) {
    this._event = event;
  }

  get dataId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get data(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get asserter(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get assertionId(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }
}

export class DataAssertionResolved extends ethereum.Event {
  get params(): DataAssertionResolved__Params {
    return new DataAssertionResolved__Params(this);
  }
}

export class DataAssertionResolved__Params {
  _event: DataAssertionResolved;

  constructor(event: DataAssertionResolved) {
    this._event = event;
  }

  get dataId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get data(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get asserter(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get assertionId(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }
}

export class OwnershipTransferStarted extends ethereum.Event {
  get params(): OwnershipTransferStarted__Params {
    return new OwnershipTransferStarted__Params(this);
  }
}

export class OwnershipTransferStarted__Params {
  _event: OwnershipTransferStarted;

  constructor(event: OwnershipTransferStarted) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ProviderAdded extends ethereum.Event {
  get params(): ProviderAdded__Params {
    return new ProviderAdded__Params(this);
  }
}

export class ProviderAdded__Params {
  _event: ProviderAdded;

  constructor(event: ProviderAdded) {
    this._event = event;
  }

  get dataId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get name(): string {
    return this._event.parameters[1].value.toString();
  }

  get dataJsonHash(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get description(): string {
    return this._event.parameters[3].value.toString();
  }

  get fee(): ProviderAddedFeeStruct {
    return changetype<ProviderAddedFeeStruct>(
      this._event.parameters[4].value.toTuple()
    );
  }

  get endTimeStamp(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get bond(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get currency(): Address {
    return this._event.parameters[7].value.toAddress();
  }

  get providerAddress(): Address {
    return this._event.parameters[8].value.toAddress();
  }

  get assertionLiveness(): BigInt {
    return this._event.parameters[9].value.toBigInt();
  }
}

export class ProviderAddedFeeStruct extends ethereum.Tuple {
  get fee(): BigInt {
    return this[0].toBigInt();
  }

  get decimals(): BigInt {
    return this[1].toBigInt();
  }
}

export class Provider__addContestResult {
  value0: boolean;
  value1: Bytes;

  constructor(value0: boolean, value1: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytes(this.value1));
    return map;
  }

  get_success(): boolean {
    return this.value0;
  }

  get_contestId(): Bytes {
    return this.value1;
  }
}

export class Provider__assertDataResult {
  value0: boolean;
  value1: Bytes;

  constructor(value0: boolean, value1: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytes(this.value1));
    return map;
  }

  getValue0(): boolean {
    return this.value0;
  }

  getValue1(): Bytes {
    return this.value1;
  }
}

export class Provider__getAllDataIdDetailsResult_completeDataStruct extends ethereum.Tuple {
  get dataId(): Bytes {
    return this[0].toBytes();
  }

  get dataDetails(): Provider__getAllDataIdDetailsResult_completeDataDataDetailsStruct {
    return changetype<
      Provider__getAllDataIdDetailsResult_completeDataDataDetailsStruct
    >(this[1].toTuple());
  }

  get providerDetails(): Provider__getAllDataIdDetailsResult_completeDataProviderDetailsStruct {
    return changetype<
      Provider__getAllDataIdDetailsResult_completeDataProviderDetailsStruct
    >(this[2].toTuple());
  }

  get assertionDetails(): Provider__getAllDataIdDetailsResult_completeDataAssertionDetailsStruct {
    return changetype<
      Provider__getAllDataIdDetailsResult_completeDataAssertionDetailsStruct
    >(this[3].toTuple());
  }
}

export class Provider__getAllDataIdDetailsResult_completeDataDataDetailsStruct extends ethereum.Tuple {
  get dataJsonHash(): Bytes {
    return this[0].toBytes();
  }

  get name(): string {
    return this[1].toString();
  }

  get imageIpfsHash(): string {
    return this[2].toString();
  }

  get description(): string {
    return this[3].toString();
  }

  get template(): string {
    return this[4].toString();
  }
}

export class Provider__getAllDataIdDetailsResult_completeDataProviderDetailsStruct extends ethereum.Tuple {
  get providerAddress(): Address {
    return this[0].toAddress();
  }

  get bond(): BigInt {
    return this[1].toBigInt();
  }

  get fee(): Provider__getAllDataIdDetailsResult_completeDataProviderDetailsFeeStruct {
    return changetype<
      Provider__getAllDataIdDetailsResult_completeDataProviderDetailsFeeStruct
    >(this[2].toTuple());
  }

  get endTimeStamp(): BigInt {
    return this[3].toBigInt();
  }

  get assertionLiveness(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }
}

export class Provider__getAllDataIdDetailsResult_completeDataProviderDetailsFeeStruct extends ethereum.Tuple {
  get fee(): BigInt {
    return this[0].toBigInt();
  }

  get decimals(): BigInt {
    return this[1].toBigInt();
  }
}

export class Provider__getAllDataIdDetailsResult_completeDataAssertionDetailsStruct extends ethereum.Tuple {
  get dataId(): Bytes {
    return this[0].toBytes();
  }

  get data(): Bytes {
    return this[1].toBytes();
  }

  get asserter(): Address {
    return this[2].toAddress();
  }

  get resolved(): boolean {
    return this[3].toBoolean();
  }
}

export class Provider__getDataIdDetailsResult_completeDataStruct extends ethereum.Tuple {
  get dataId(): Bytes {
    return this[0].toBytes();
  }

  get dataDetails(): Provider__getDataIdDetailsResult_completeDataDataDetailsStruct {
    return changetype<
      Provider__getDataIdDetailsResult_completeDataDataDetailsStruct
    >(this[1].toTuple());
  }

  get providerDetails(): Provider__getDataIdDetailsResult_completeDataProviderDetailsStruct {
    return changetype<
      Provider__getDataIdDetailsResult_completeDataProviderDetailsStruct
    >(this[2].toTuple());
  }

  get assertionDetails(): Provider__getDataIdDetailsResult_completeDataAssertionDetailsStruct {
    return changetype<
      Provider__getDataIdDetailsResult_completeDataAssertionDetailsStruct
    >(this[3].toTuple());
  }
}

export class Provider__getDataIdDetailsResult_completeDataDataDetailsStruct extends ethereum.Tuple {
  get dataJsonHash(): Bytes {
    return this[0].toBytes();
  }

  get name(): string {
    return this[1].toString();
  }

  get imageIpfsHash(): string {
    return this[2].toString();
  }

  get description(): string {
    return this[3].toString();
  }

  get template(): string {
    return this[4].toString();
  }
}

export class Provider__getDataIdDetailsResult_completeDataProviderDetailsStruct extends ethereum.Tuple {
  get providerAddress(): Address {
    return this[0].toAddress();
  }

  get bond(): BigInt {
    return this[1].toBigInt();
  }

  get fee(): Provider__getDataIdDetailsResult_completeDataProviderDetailsFeeStruct {
    return changetype<
      Provider__getDataIdDetailsResult_completeDataProviderDetailsFeeStruct
    >(this[2].toTuple());
  }

  get endTimeStamp(): BigInt {
    return this[3].toBigInt();
  }

  get assertionLiveness(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }
}

export class Provider__getDataIdDetailsResult_completeDataProviderDetailsFeeStruct extends ethereum.Tuple {
  get fee(): BigInt {
    return this[0].toBigInt();
  }

  get decimals(): BigInt {
    return this[1].toBigInt();
  }
}

export class Provider__getDataIdDetailsResult_completeDataAssertionDetailsStruct extends ethereum.Tuple {
  get dataId(): Bytes {
    return this[0].toBytes();
  }

  get data(): Bytes {
    return this[1].toBytes();
  }

  get asserter(): Address {
    return this[2].toAddress();
  }

  get resolved(): boolean {
    return this[3].toBoolean();
  }
}

export class Provider__getProviderFeeResult {
  value0: BigInt;
  value1: BigInt;
  value2: Address;

  constructor(value0: BigInt, value1: BigInt, value2: Address) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    return map;
  }

  getFee(): BigInt {
    return this.value0;
  }

  getDecimals(): BigInt {
    return this.value1;
  }

  get_providerAddress(): Address {
    return this.value2;
  }
}

export class Provider__getResolvedDataResult {
  value0: boolean;
  value1: Bytes;

  constructor(value0: boolean, value1: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromBytes(this.value1));
    return map;
  }

  getValue0(): boolean {
    return this.value0;
  }

  getValue1(): Bytes {
    return this.value1;
  }
}

export class Provider__getSupportedCurrenciesResult_resultStruct extends ethereum.Tuple {
  get _symbol(): string {
    return this[0].toString();
  }

  get _address(): Address {
    return this[1].toAddress();
  }

  get _uint(): BigInt {
    return this[2].toBigInt();
  }
}

export class Provider extends ethereum.SmartContract {
  static bind(address: Address): Provider {
    return new Provider("Provider", address);
  }

  addContest(_dataId: Bytes, _data: Bytes): Provider__addContestResult {
    let result = super.call(
      "addContest",
      "addContest(bytes32,bytes):(bool,bytes32)",
      [ethereum.Value.fromFixedBytes(_dataId), ethereum.Value.fromBytes(_data)]
    );

    return new Provider__addContestResult(
      result[0].toBoolean(),
      result[1].toBytes()
    );
  }

  try_addContest(
    _dataId: Bytes,
    _data: Bytes
  ): ethereum.CallResult<Provider__addContestResult> {
    let result = super.tryCall(
      "addContest",
      "addContest(bytes32,bytes):(bool,bytes32)",
      [ethereum.Value.fromFixedBytes(_dataId), ethereum.Value.fromBytes(_data)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Provider__addContestResult(value[0].toBoolean(), value[1].toBytes())
    );
  }

  assertData(_dataId: Bytes, _data: Bytes): Provider__assertDataResult {
    let result = super.call(
      "assertData",
      "assertData(bytes32,bytes):(bool,bytes32)",
      [ethereum.Value.fromFixedBytes(_dataId), ethereum.Value.fromBytes(_data)]
    );

    return new Provider__assertDataResult(
      result[0].toBoolean(),
      result[1].toBytes()
    );
  }

  try_assertData(
    _dataId: Bytes,
    _data: Bytes
  ): ethereum.CallResult<Provider__assertDataResult> {
    let result = super.tryCall(
      "assertData",
      "assertData(bytes32,bytes):(bool,bytes32)",
      [ethereum.Value.fromFixedBytes(_dataId), ethereum.Value.fromBytes(_data)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Provider__assertDataResult(value[0].toBoolean(), value[1].toBytes())
    );
  }

  defaultIdentifier(): Bytes {
    let result = super.call(
      "defaultIdentifier",
      "defaultIdentifier():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_defaultIdentifier(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "defaultIdentifier",
      "defaultIdentifier():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  escalationManager(): Address {
    let result = super.call(
      "escalationManager",
      "escalationManager():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_escalationManager(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "escalationManager",
      "escalationManager():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  finder(): Address {
    let result = super.call("finder", "finder():(address)", []);

    return result[0].toAddress();
  }

  try_finder(): ethereum.CallResult<Address> {
    let result = super.tryCall("finder", "finder():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getAllDataIdDetails(): Array<
    Provider__getAllDataIdDetailsResult_completeDataStruct
  > {
    let result = super.call(
      "getAllDataIdDetails",
      "getAllDataIdDetails():((bytes32,(bytes32,string,string,string,string),(address,uint256,(uint256,uint256),uint256,uint64,address),(bytes32,bytes,address,bool))[])",
      []
    );

    return result[0].toTupleArray<
      Provider__getAllDataIdDetailsResult_completeDataStruct
    >();
  }

  try_getAllDataIdDetails(): ethereum.CallResult<
    Array<Provider__getAllDataIdDetailsResult_completeDataStruct>
  > {
    let result = super.tryCall(
      "getAllDataIdDetails",
      "getAllDataIdDetails():((bytes32,(bytes32,string,string,string,string),(address,uint256,(uint256,uint256),uint256,uint64,address),(bytes32,bytes,address,bool))[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<
        Provider__getAllDataIdDetailsResult_completeDataStruct
      >()
    );
  }

  getDataIdDetails(
    _dataId: Bytes
  ): Provider__getDataIdDetailsResult_completeDataStruct {
    let result = super.call(
      "getDataIdDetails",
      "getDataIdDetails(bytes32):((bytes32,(bytes32,string,string,string,string),(address,uint256,(uint256,uint256),uint256,uint64,address),(bytes32,bytes,address,bool)))",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );

    return changetype<Provider__getDataIdDetailsResult_completeDataStruct>(
      result[0].toTuple()
    );
  }

  try_getDataIdDetails(
    _dataId: Bytes
  ): ethereum.CallResult<Provider__getDataIdDetailsResult_completeDataStruct> {
    let result = super.tryCall(
      "getDataIdDetails",
      "getDataIdDetails(bytes32):((bytes32,(bytes32,string,string,string,string),(address,uint256,(uint256,uint256),uint256,uint64,address),(bytes32,bytes,address,bool)))",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Provider__getDataIdDetailsResult_completeDataStruct>(
        value[0].toTuple()
      )
    );
  }

  getDataIdList(): Array<Bytes> {
    let result = super.call("getDataIdList", "getDataIdList():(bytes32[])", []);

    return result[0].toBytesArray();
  }

  try_getDataIdList(): ethereum.CallResult<Array<Bytes>> {
    let result = super.tryCall(
      "getDataIdList",
      "getDataIdList():(bytes32[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytesArray());
  }

  getDataIdTemplate(_dataId: Bytes): string {
    let result = super.call(
      "getDataIdTemplate",
      "getDataIdTemplate(bytes32):(string)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );

    return result[0].toString();
  }

  try_getDataIdTemplate(_dataId: Bytes): ethereum.CallResult<string> {
    let result = super.tryCall(
      "getDataIdTemplate",
      "getDataIdTemplate(bytes32):(string)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  getProviderFee(_dataId: Bytes): Provider__getProviderFeeResult {
    let result = super.call(
      "getProviderFee",
      "getProviderFee(bytes32):(uint256,uint256,address)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );

    return new Provider__getProviderFeeResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toAddress()
    );
  }

  try_getProviderFee(
    _dataId: Bytes
  ): ethereum.CallResult<Provider__getProviderFeeResult> {
    let result = super.tryCall(
      "getProviderFee",
      "getProviderFee(bytes32):(uint256,uint256,address)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Provider__getProviderFeeResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toAddress()
      )
    );
  }

  getResolvedData(_dataId: Bytes): Provider__getResolvedDataResult {
    let result = super.call(
      "getResolvedData",
      "getResolvedData(bytes32):(bool,bytes)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );

    return new Provider__getResolvedDataResult(
      result[0].toBoolean(),
      result[1].toBytes()
    );
  }

  try_getResolvedData(
    _dataId: Bytes
  ): ethereum.CallResult<Provider__getResolvedDataResult> {
    let result = super.tryCall(
      "getResolvedData",
      "getResolvedData(bytes32):(bool,bytes)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Provider__getResolvedDataResult(
        value[0].toBoolean(),
        value[1].toBytes()
      )
    );
  }

  getSupportedCurrencies(): Array<
    Provider__getSupportedCurrenciesResult_resultStruct
  > {
    let result = super.call(
      "getSupportedCurrencies",
      "getSupportedCurrencies():((string,address,uint256)[])",
      []
    );

    return result[0].toTupleArray<
      Provider__getSupportedCurrenciesResult_resultStruct
    >();
  }

  try_getSupportedCurrencies(): ethereum.CallResult<
    Array<Provider__getSupportedCurrenciesResult_resultStruct>
  > {
    let result = super.tryCall(
      "getSupportedCurrencies",
      "getSupportedCurrencies():((string,address,uint256)[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<
        Provider__getSupportedCurrenciesResult_resultStruct
      >()
    );
  }

  isDataAsserted(_dataId: Bytes): boolean {
    let result = super.call(
      "isDataAsserted",
      "isDataAsserted(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );

    return result[0].toBoolean();
  }

  try_isDataAsserted(_dataId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isDataAsserted",
      "isDataAsserted(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  oo(): Address {
    let result = super.call("oo", "oo():(address)", []);

    return result[0].toAddress();
  }

  try_oo(): ethereum.CallResult<Address> {
    let result = super.tryCall("oo", "oo():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  pendingOwner(): Address {
    let result = super.call("pendingOwner", "pendingOwner():(address)", []);

    return result[0].toAddress();
  }

  try_pendingOwner(): ethereum.CallResult<Address> {
    let result = super.tryCall("pendingOwner", "pendingOwner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  resolve(_dataId: Bytes): boolean {
    let result = super.call("resolve", "resolve(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(_dataId)
    ]);

    return result[0].toBoolean();
  }

  try_resolve(_dataId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall("resolve", "resolve(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(_dataId)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  validateDataIdandSender(_dataId: Bytes, _address: Address): boolean {
    let result = super.call(
      "validateDataIdandSender",
      "validateDataIdandSender(bytes32,address):(bool)",
      [
        ethereum.Value.fromFixedBytes(_dataId),
        ethereum.Value.fromAddress(_address)
      ]
    );

    return result[0].toBoolean();
  }

  try_validateDataIdandSender(
    _dataId: Bytes,
    _address: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "validateDataIdandSender",
      "validateDataIdandSender(bytes32,address):(bool)",
      [
        ethereum.Value.fromFixedBytes(_dataId),
        ethereum.Value.fromAddress(_address)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  validatePlaceBet(_dataId: Bytes): boolean {
    let result = super.call(
      "validatePlaceBet",
      "validatePlaceBet(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );

    return result[0].toBoolean();
  }

  try_validatePlaceBet(_dataId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "validatePlaceBet",
      "validatePlaceBet(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(_dataId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _finder(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _locator(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall extends ethereum.Call {
  get inputs(): AcceptOwnershipCall__Inputs {
    return new AcceptOwnershipCall__Inputs(this);
  }

  get outputs(): AcceptOwnershipCall__Outputs {
    return new AcceptOwnershipCall__Outputs(this);
  }
}

export class AcceptOwnershipCall__Inputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall__Outputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AddContestCall extends ethereum.Call {
  get inputs(): AddContestCall__Inputs {
    return new AddContestCall__Inputs(this);
  }

  get outputs(): AddContestCall__Outputs {
    return new AddContestCall__Outputs(this);
  }
}

export class AddContestCall__Inputs {
  _call: AddContestCall;

  constructor(call: AddContestCall) {
    this._call = call;
  }

  get _dataId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _data(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class AddContestCall__Outputs {
  _call: AddContestCall;

  constructor(call: AddContestCall) {
    this._call = call;
  }

  get _success(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }

  get _contestId(): Bytes {
    return this._call.outputValues[1].value.toBytes();
  }
}

export class AddProviderCall extends ethereum.Call {
  get inputs(): AddProviderCall__Inputs {
    return new AddProviderCall__Inputs(this);
  }

  get outputs(): AddProviderCall__Outputs {
    return new AddProviderCall__Outputs(this);
  }
}

export class AddProviderCall__Inputs {
  _call: AddProviderCall;

  constructor(call: AddProviderCall) {
    this._call = call;
  }

  get _name(): string {
    return this._call.inputValues[0].value.toString();
  }

  get _description(): string {
    return this._call.inputValues[1].value.toString();
  }

  get _imageIpfsHash(): string {
    return this._call.inputValues[2].value.toString();
  }

  get _dataJsonHash(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get _fee(): AddProviderCall_feeStruct {
    return changetype<AddProviderCall_feeStruct>(
      this._call.inputValues[4].value.toTuple()
    );
  }

  get _endTimeStamp(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get _bond(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }

  get _currency(): Address {
    return this._call.inputValues[7].value.toAddress();
  }

  get _providerAddress(): Address {
    return this._call.inputValues[8].value.toAddress();
  }

  get _assertionLiveness(): BigInt {
    return this._call.inputValues[9].value.toBigInt();
  }

  get _template(): string {
    return this._call.inputValues[10].value.toString();
  }

  get _templateData(): Bytes {
    return this._call.inputValues[11].value.toBytes();
  }
}

export class AddProviderCall__Outputs {
  _call: AddProviderCall;

  constructor(call: AddProviderCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }

  get value1(): Bytes {
    return this._call.outputValues[1].value.toBytes();
  }
}

export class AddProviderCall_feeStruct extends ethereum.Tuple {
  get fee(): BigInt {
    return this[0].toBigInt();
  }

  get decimals(): BigInt {
    return this[1].toBigInt();
  }
}

export class AssertDataCall extends ethereum.Call {
  get inputs(): AssertDataCall__Inputs {
    return new AssertDataCall__Inputs(this);
  }

  get outputs(): AssertDataCall__Outputs {
    return new AssertDataCall__Outputs(this);
  }
}

export class AssertDataCall__Inputs {
  _call: AssertDataCall;

  constructor(call: AssertDataCall) {
    this._call = call;
  }

  get _dataId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _data(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class AssertDataCall__Outputs {
  _call: AssertDataCall;

  constructor(call: AssertDataCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }

  get value1(): Bytes {
    return this._call.outputValues[1].value.toBytes();
  }
}

export class AssertionDisputedCallbackCall extends ethereum.Call {
  get inputs(): AssertionDisputedCallbackCall__Inputs {
    return new AssertionDisputedCallbackCall__Inputs(this);
  }

  get outputs(): AssertionDisputedCallbackCall__Outputs {
    return new AssertionDisputedCallbackCall__Outputs(this);
  }
}

export class AssertionDisputedCallbackCall__Inputs {
  _call: AssertionDisputedCallbackCall;

  constructor(call: AssertionDisputedCallbackCall) {
    this._call = call;
  }

  get assertionId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class AssertionDisputedCallbackCall__Outputs {
  _call: AssertionDisputedCallbackCall;

  constructor(call: AssertionDisputedCallbackCall) {
    this._call = call;
  }
}

export class AssertionResolvedCallbackCall extends ethereum.Call {
  get inputs(): AssertionResolvedCallbackCall__Inputs {
    return new AssertionResolvedCallbackCall__Inputs(this);
  }

  get outputs(): AssertionResolvedCallbackCall__Outputs {
    return new AssertionResolvedCallbackCall__Outputs(this);
  }
}

export class AssertionResolvedCallbackCall__Inputs {
  _call: AssertionResolvedCallbackCall;

  constructor(call: AssertionResolvedCallbackCall) {
    this._call = call;
  }

  get _assertionId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _assertedTruthfully(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class AssertionResolvedCallbackCall__Outputs {
  _call: AssertionResolvedCallbackCall;

  constructor(call: AssertionResolvedCallbackCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class ResolveCall extends ethereum.Call {
  get inputs(): ResolveCall__Inputs {
    return new ResolveCall__Inputs(this);
  }

  get outputs(): ResolveCall__Outputs {
    return new ResolveCall__Outputs(this);
  }
}

export class ResolveCall__Inputs {
  _call: ResolveCall;

  constructor(call: ResolveCall) {
    this._call = call;
  }

  get _dataId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class ResolveCall__Outputs {
  _call: ResolveCall;

  constructor(call: ResolveCall) {
    this._call = call;
  }

  get _success(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}
